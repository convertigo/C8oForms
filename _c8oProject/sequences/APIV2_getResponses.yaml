↓computeResponses [steps.SimpleStep-1697532248606]: 
  expression: |
    '// Imports and helpers functions
    include("js/common.js");
    Otherkey = "Other";
    const logLevel = "warn";
    var res = {};
    var i = 0;
    var table = [];
    csv = csv == "true";
    let meta;
    let max_len = 120;
    try{
    	meta = JSON.parse(meta);
    }
    catch(e){
    	
    }
    // start functions
    var getI18nForCsv = (key, lang) =>{
    	if(key == "timestamp"){
    		switch(""+lang){
    			case "en":
    			case "fr":
    				return "Date";
    			case "es":
    				return "Fecha";
    			case "it":
    				return "Data";
    			default:
    				return "Date";
    		}
    	}
    	else if(key == "author"){
    		switch(""+lang){
    			case "en":
    				return "Author";
    			case "fr":
    				return "Auteur";
    			case "es":
    				return "Autor";
    			case "it":
    				return "Autore";
    			default:
    				return "Author";
    		}
    	}
    	else if(key == "anonymous"){
    		switch(""+lang){
    			case "en":
    				return "Anonymous user";
    			case "fr":
    				return "Utilisateur anonyme";
    			case "es":
    				return "Usuario anónimo";
    			case "it":
    				return "Utente anonimo";
    			default:
    				return "Anonymous user";
    		}
    	}
    	return key;
    	
    }
    // used to format responses, will be used recursively
    
    // used to format responses, will be used recursively
    var extractResponse = (response, _i, type, _id, responseArray, structure, csv, opts) => {
    	switch (type) {
    		case "text":
    		case "datetime":
    		case "time":
    		case "barcode":
    			if (response.value != "") {
    				responseArray[_i].value.push(response.value);
    			}
    			break;
    		case "signature":
    		case "img":
    			if (response.value != "") {
    				if (j == 0) {
    					try { structure[_i].att_type = response.att_type == true; } catch (e) { }
    				}
    				if (structure[_i].att_type) {
    					var _val = context.getConvertigoUrl() + "fullsync/c8oforms_response_fs/" + encodeURIComponent(_id) + "/" + encodeURIComponent(response.name);
    					responseArray[_i].value.push(_val);
    				}
    				else {
    					responseArray[_i].value.push(response.value);
    				}
    			}
    			break;
    		case "location":
    			if (Object.keys(response.value.gps).length > 0) {
    				if (response["value"]["bounding_box"] != undefined) {
    					response.value = JSON.stringify(response["value"]["bounding_box"]);
    				}
    				else if (response["value"]["addr"] != undefined && response["value"]["addr"]["FormattedAddress"] != undefined && response["value"]["addr"]["FormattedAddress"] != "") {
    					response.value = response["value"]["addr"]["FormattedAddress"];
    				}
    				else {
    					response.value = { text: "Latitude : " + response["value"]["gps"]["latitude"] + ", Longitude : " + response["value"]["gps"]["longitude"] + ", précision : " + ("" + response["value"]["gps"]["accuracy"]).split(".")[0] + " métres", gps: response["value"]["gps"] };
    				}
    				responseArray[_i].value.push(response.value);
    			}
    			break;
    		case "grid":
    			if (response.value != null && response.value != "" && JSON.stringify(response.value) != "{}") {
    				var val;
    				if (!(response.value instanceof String)) {
    					val = JSON.stringify(response.value);
    				}
    				else {
    					val = response.value;
    				}
    				responseArray[_i].value.push(val);
    			}
    			break;
    		case "file":
    			if (response.value != "") {
    				var first = true;
    				var values = [];
    				if (response.value instanceof Array) {
    					for (var entryFile of response.value) {
    						if (typeof (entryFile) === "string") {
    							values.push({ "name": entryFile.split("_C80C80_")[1], "url": context.getConvertigoUrl() + "fullsync/c8oforms_response_fs/" + encodeURIComponent(_id) + "/" + encodeURIComponent(entryFile) });
    						}
    					}
    				}
    				responseArray[_i].value = responseArray[_i].value.concat(values);
    				// if for csv just give file url
    				if(csv){
    					responseArray[_i].value = responseArray[_i].value.map((x)=>{
    						return x.url;
    					})
    				}
    			}
    			break;
    		case "checkbox":
    		case "radio":
    		case "select":
    			for (var k in response["children"]) {
    				if (responseArray[_i].value[k] == undefined) {
    					responseArray[_i].value[k] = 0;
    				}
    				if (j == 0) {
    					if (response["children"][k].other == true) {
    						structure[_i].categories[k] = Otherkey;
    					}
    					else {
    						structure[_i].categories[k] = response["children"][k]["value"].length > max_len ? response["children"][k]["value"].substring(0, max_len) + "..." : response["children"][k]["value"];
    					}
    				}
    				if (response["children"][k]["selected"] == true) {
    					responseArray[_i].value[k]++
    				}
    			}
    			// if for csv replace number of occurence by structure value
    			if(csv){
    				var val = responseArray[_i].value;
    				var cat = structure[_i].categories;
    				var _temp = [];
    				for(var l = 0; l < val.length; l++){
    					if(val[l] == 1){
    						_temp.push(cat[l]);
    					}
    				}
    				responseArray[_i].value = _temp;
    			}
    			break;
    		case "checkbox_group":
    			var offsetCreated = 0;
    			var m = 0;
    			for (var k in response["children"]) {
    				structure[_i]["categories"][m] = k.length > max_len ? k.substring(0, max_len) + "..." : k;
    				for (var l in response["children"][k]) {
    					if (responseArray[_i]["value"][+l] == undefined) {
    						responseArray[_i]["value"][+l] = {};
    					}
    					if (responseArray[_i]["value"][+l]["name"] == undefined) {
    						responseArray[_i]["value"][+l]["name"] = response["children"][k][l]["value"].length > max_len ? response["children"][k][l]["value"].substring(0, max_len) + "..." : response["children"][k][l]["value"];
    					}
    					if (responseArray[_i]["value"][+l]["data"] == undefined) {
    						responseArray[_i]["value"][+l]["data"] = [];
    					}
    					if (responseArray[_i]["value"][+l]["data"][m] == undefined) {
    						responseArray[_i]["value"][+l]["data"][m] = 0;
    					}
    					if (response["children"][k][l]["selected"] == true) {
    						responseArray[_i]["value"][+l]["data"][m]++;
    					}
    				}
    				m++;
    			}
    			// if for csv add type to allow more complexe computations in APIV2_CSV sequence
    			if(csv){
    				responseArray[_i].type = type;
    			}
    			break;
    		case "radio_group":
    			m = 0;
    			for (var k in response["children"]) {
    				structure[_i]["categories"][m] = k.length > max_len ? k.substring(0, max_len) + "..." : k;
    				for (var l in response["children_label"]) {
    					if (responseArray[_i]["value"][+l] == undefined) {
    						responseArray[_i]["value"][+l] = {};
    					}
    					if (responseArray[_i]["value"][+l]["name"] == undefined) {
    						responseArray[_i]["value"][+l]["name"] = response["children_label"][+l]["value"].length > max_len ? response["children_label"][+l]["value"].substring(0, max_len) + "..." : response["children_label"][+l]["value"];
    					}
    					if (responseArray[_i]["value"][+l]["data"] == undefined) {
    						responseArray[_i]["value"][+l]["data"] = [];
    					}
    					if (responseArray[_i]["value"][+l]["data"][m] == undefined) {
    						responseArray[_i]["value"][+l]["data"][m] = 0;
    					}
    					if (response["children_label"][l].value == response["children"][k]) {
    						responseArray[_i]["value"][+l]["data"][m]++;
    					}
    				}
    				m++;
    			}
    			// if for csv add type to allow more complexe computations in APIV2_CSV sequence
    			if(csv){
    				responseArray[_i].type = type;
    			}
    			break;
    		case "slider":
    			if (response["value"] !== "") {
    				if (structure[_i]["categories"].length === 0) {
    					structure[_i]["categories"].push("");
    				}
    				if (table == undefined) {
    					table = [];
    				}
    				if (table[_i] == undefined) {
    					table[_i] = {};
    				}
    				if (table[_i][response["value"]] == undefined) {
    					table[_i][response["value"]] = responseArray[_i]["value"].push({ data: [1], name: response["value"] }) - 1;
    				}
    				else {
    					var index = table[_i][response["value"]];
    					var count = responseArray[_i]["value"][index]["data"][0];
    					responseArray[_i]["value"][index]["data"] = [count + 1];
    				}
    				if(csv){
    					let responded = responseArray[_i]["value"][0].data[0] === 1;
    					if(responded){
    						responseArray[_i]["value"] = [responseArray[_i]["value"][0].name];
    					}
    				}
    			}
    			break;
    		case "actionValue":
    			if (response["valueType"] == "attachment") {
    				if (i == 0) {
    					structure[_i].att_type = true;
    				}
    				responseArray[_i].value.push({ "name": response.value, "url": context.getConvertigoUrl() + "fullsync/c8oforms_response_fs/" + encodeURIComponent(_id) + "/" + encodeURIComponent(response.value) });
    			}
    			else {
    				responseArray[_i].value.push(response.value);
    			}
    			break;
    		case "timestamp":
    			var offsetDiff = (opts != null && opts.offsetDiff != null) ? opts.offsetDiff : 0;
    			responseArray[_i].value.push(getFormattedDate(new Date(+response +offsetDiff)));
    			break;
    		case "author":
    			if(opts && opts.transform){
    				try {
    					let resp = getDoc("C8Oreserved_"+response,null, "c8oforms_fs");
    					if(!resp.error){
    						if(resp.displayName){
    							response = resp.displayName;
    						}
    						else if(resp.mail){
    							response = resp.mail;
    						}
    					}
    				}	
    				catch(e){}
    			}
    			responseArray[_i].value.push(response);
    			break;
    	}
    }
    //start code
    var published_form;
    try {
    	published_form = (callSequence("C8Oforms", "APIV2_getDocument", { id: formId })).document.res;
    }
    catch (e) {
    	var to = e;
    }
    // if authorized and exists doc
    if (published_form) {
    	//res["raw_published_form"] = published_form;
    	res["published_form"] = { name: published_form.name };
    	var currentVersion;
    	// define all existing version for this form
    	res["versions"] = createArray(published_form.version);
    	if (version && version != "") {
    		currentVersion = +version;
    	}
    	else {
    		currentVersion = +published_form.version;
    	}
    	res["currentVersion"] = currentVersion;
    	query = new java.util.HashMap();
    	query.put(''reduce'', ''false'');
    	query.put(''startkey'', JSON.stringify([formId, "" + currentVersion]));
    	query.put(''endkey'', JSON.stringify([formId, "" + currentVersion]));
    	query.put("include_docs", "true");
    	var responses;
    	responses = toJSON(fsclient.getView("c8oforms_response_fs", ''read_responses'', ''getResponsesByVersion'', query)).rows;
    	res.response = { length: responses.length };
    	//res["raw_responses"] = responses;
    
    	var sortedsIds = [];
    	var lenActions = 0;
    
    	// if we are in forms 2.0 responses, sortedsIds are stored in response itself
    	if (responses[0] && responses[0].doc && responses[0].doc.sortedsIds) {
    		sortedsIds = responses[0].doc.sortedsIds;
    		lenActions = responses[0].doc.lenActions;
    		res.response.sort = true;
    	}
    	// if form was created before forms 2.0 release, responses doean''t contains sortedsIds. => we can compute it from actual publidhed form
    	else if (+published_form.version == +currentVersion) {
    		published_form.pages.forEach((page, index) => {
    			var _tempArr = published_form.formulaire.filter((x) => {
    				return x.config.page == page.pageTechName;
    			}).flatMap((x) => {
    				if (x.type === "ion-card") {
    					var prefix = x.name;
    					const _temp_subArray = x.children.map((y) => {
    						return { path: prefix + ".children." + y.name, type: y.type };
    					});
    					return _temp_subArray;
    				}
    				else {
    					return { path: x.name, type: x.type };
    
    				}
    			});
    			sortedsIds = sortedsIds.concat(_tempArr);
    		});
    		lenActions = published_form.actions.filter((x) => { return x.type === "submit" }).length;
    		res.response.sort = true;
    	}
    	// if none of both previous conditions are met, we can''t sort responses.
    	else {
    		// not sorted responses for old versions
    		var _tempArr = [];
    		for (var e in responses[0].doc.resp) {
    			x = responses[0].doc.resp[e];
    			if (x.type === "ion-card") {
    				var prefix = x.name;
    				for (var f in x.children) {
    					y = x.children[f];
    					_tempArr.push({ path: prefix + ".children." + y.name, type: y.type });
    				}
    			}
    			else {
    				_tempArr.push({ path: x.name, type: x.type });
    
    			}
    		}
    		sortedsIds = sortedsIds.concat(_tempArr);
    		console.log("sortedIds", sortedsIds, logLevel);
    		res.response.sort = false;
    		if (responses[0].doc.actionsValue) {
    			lenActions = Object.keys(responses[0].doc.actionsValue).length;
    		}
    	}
    	if(csv){
    		let arrayCsv = [{path: ''/.doc.timestamp'', type:"timestamp", meta: {}}];
    		if(meta){
    			if(meta.offset){
    				var offSetServer = new Date().getTimezoneOffset() * 60000 * -1;
    				offset = +meta.offset;
    				arrayCsv[0].meta.offsetDiff = offset - offSetServer;
    			}
    			if(meta.authorId){
    				arrayCsv.push({path: ''/.doc.~c8oAcl'', type:"author", meta: {transform: false}});
    			}
    			else if(meta.authorName){
    				arrayCsv.push({path: ''/.doc.~c8oAcl'', type:"author", meta: {transform: true}});
    			}
    		}
    		sortedsIds = arrayCsv.concat(sortedsIds);
    	}
    
    	// sorted responses for current versions
    	var len = sortedsIds.length;
    	var lenResponses = responses.length;
    
    	// if export to csv mode
    	var nestedResponses;
    	if (summary != "true") {
    		nestedResponses = [];
    	}
    	var flatResponses = [];
    	
    	// go over each fields of the form
    	for (var i = 0; i < len; i++) {
    		// go over each responses
    		for (var j = 0; j < lenResponses; j++) {
    			// create resp struct
    			var prefix = false;
    			var s = sortedsIds[i].path.split(".");
    			var response;
    			if(s[0] != "/"){
    				response = responses[j].doc.resp;
    			}
    			else{
    				response = responses[j];
    				prefix = true;
    				s.shift();
    			}
    			var elem;
    			for (var part of s) {
    				response = response[part];
    				elem = part;
    			}
    			if (response) {
    				if (j == 0) {
    					// prefix for csv as timestamp or author
    					if(prefix){
    						let i18nKey = getI18nForCsv(sortedsIds[i].type, (meta && meta.lang) ? meta.lang : "en");
    						flatResponses[i] = { "id": i18nKey, att_type: false, "label": i18nKey, "labelHtml": i18nKey, "type": sortedsIds[i].type, "name": i18nKey };
    					}
    					else{
    						flatResponses[i] = { "id": elem, att_type: false, "label": response.label, "labelHtml": response.labelHtml, "type": response.type, categories: [], "name": response.name };
    					}
    					if(nestedResponses == undefined){
    						flatResponses[i]["value"] = [];
    					}
    				}
    				if(nestedResponses != undefined){
    					if (nestedResponses[j] == undefined) {
    						nestedResponses[j] = [];
    					}
    					if(nestedResponses[j][i] == undefined){
    						nestedResponses[j][i] = { value: []};
    					}
    					extractResponse(response, i, sortedsIds[i].type, responses[j].id, nestedResponses[j], flatResponses, csv, sortedsIds[i].meta);
    					
    				}
    				else{
    					extractResponse(response, i, sortedsIds[i].type, responses[j].id, flatResponses, flatResponses, csv, null);
    				}
    				
    			}
    		}
    	}
    	var k = +("" + flatResponses.length);
    
    	// go over each actions of the form
    	for (i = 0; i < lenActions; i++) {
    		// go over each responses
    		for (var j = 0; j < lenResponses; j++) {
    			if (responses[j].doc.actionsValue) {
    				var keys = Object.keys(responses[j].doc.actionsValue);
    				var indexName = keys[i];
    				var response = responses[j].doc.actionsValue[indexName];
    				if (response) {
    					response.type = "actionValue";
    					if (j == 0) {
    						flatResponses[k + i] = { "id": indexName, att_type: false, "label": indexName, "labelHtml": indexName, "type": "actionValue", "name": indexName };
    						if(nestedResponses == undefined){
    							flatResponses[k + i]["value"] = [];
    						}
    					}
    					if(nestedResponses != undefined){
    						if (nestedResponses[j] == undefined) {
    							nestedResponses[j] = [];
    						}
    						if(nestedResponses[j][k + i] == undefined){
    							nestedResponses[j][k + i] = { value: []};
    						}
    						extractResponse(response, k + i, response.type, responses[j].id, nestedResponses[j], flatResponses, csv, null);
    					}
    					else{
    						extractResponse(response, k + i, response.type, responses[j].id, flatResponses, flatResponses, csv, null);
    					}
    				}
    			}
    
    		}
    
    	}
    	res.response.value = flatResponses;
    	if(nestedResponses){
    		res.response.nestedResponses = nestedResponses;
    		res.response.summerized = false;
    	}
    	else{
    		res.response.summerized = true;
    	}
    }'
↓object2 [steps.JsonToXmlStep-1697532248609]: 
  jsonObject: 
    - xmlizable: 
      - ↑classname: com.twinsoft.convertigo.beans.steps.SmartType
      - SmartType: 
        - ↑mode: JS
        - →→: res
  key: 
    - xmlizable: 
      - ↑classname: com.twinsoft.convertigo.beans.steps.SmartType
      - SmartType: 
        - ↑mode: PLAIN
        - →→: res
↓formId [variables.RequestableVariable-1697532236824]: 
  value: published_1697531850821
↓version [variables.RequestableVariable-1697536095803]: 
↓summary [variables.RequestableVariable-1699003881651]: 
  value: true
↓csv [variables.RequestableVariable-1699367933220]: 
  value: false
↓meta [variables.RequestableVariable-1707225958131]: 