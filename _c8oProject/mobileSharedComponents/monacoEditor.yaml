scriptContent: 
  - xmlizable: 
    - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
    - com.twinsoft.convertigo.beans.common.FormatedContent: 
      →: |
        '/*Begin_c8o_CompImport*/
        /*End_c8o_CompImport*/
        /*Begin_c8o_CompDeclaration*/
        	/*End_c8o_CompDeclaration*/
        /*Begin_c8o_CompConstructor*/
        		/*End_c8o_CompConstructor*/
        /*Begin_c8o_CompInitialization*/
        		/*End_c8o_CompInitialization*/
        /*Begin_c8o_CompFinalization*/
        		/*End_c8o_CompFinalization*/
        /*Begin_c8o_CompChanges*/
        		/*End_c8o_CompChanges*/
        /*Begin_c8o_CompDoCheck*/
        		/*End_c8o_CompDoCheck*/
        /*Begin_c8o_CompAfterContentInit*/
        		/*End_c8o_CompAfterContentInit*/
        /*Begin_c8o_CompAfterContentChecked*/
        		/*End_c8o_CompAfterContentChecked*/
        /*Begin_c8o_CompAfterViewInit*/
        		/*End_c8o_CompAfterViewInit*/
        /*Begin_c8o_CompAfterViewChecked*/
        		/*End_c8o_CompAfterViewChecked*/
        /*Begin_c8o_CompFunction*/
        	
        	// 
        	
        	/**
        	 * used to find tree leafs, not going more than 10 deep
        	 */
        	public recursiveGetChilds(elem, compl = false, max = 10, count = 0){
        		let str = "";
        		for(let key in elem){
        			if(typeof(elem[key]) == "string"){
        				str+= `${key}: ${compl ? "any" : elem[key]},
        				`
        			}
        			else{
        				if(count < max){
        					count++;
        					str += `${key}:{
        							`;
        					str += this.recursiveGetChilds(elem[key], compl, max, count);
        					str +=`		
        					},
        					`;
        				}
        			}
        		}
        		return str;
        	}
        	public async computeCurrentElem(elem){
        		let fields = "";
        		let defs = "";
        		// call api width model true to try to get source structure
        		let struct = await this.pageOwner.searchCompletionWithElem(elem);
        		// set Interface name (will be always field name in uppercase)
        		let InterFaceName = elem.name.charAt(0).toUpperCase() + elem.name.slice(1);
        		// store it to fields interface
        		fields += `${elem.name} : ${InterFaceName}, `;
        		
        		defs+= `
        			interface ${InterFaceName} {
        				`;
        		if(Object.keys(struct.builtin).length > 0){
        			defs += this.recursiveGetChilds(struct.builtin, false);
        		}
        		if(Object.keys(struct.compl).length > 0){
        			defs += this.recursiveGetChilds(struct.compl, true);
        		}
        		defs +=`
        			}
        		`;
        		return {defs: defs, fields: fields}
        	}
        	public async computeDefs(): Promise<string>{
        		// defs will contains the all structure for completion, starting by each form component, then Fields interface
        		let defs = "";
        		// declare fields interFace that will hold the whole fields
        		let fields = "interface Fields {";
        		// walk the whole form
        		for(let elem of this.pageOwner.form.formulaire){
        			if(elem.type == "ion-card"){
        				for(let subElem of elem.children){
        					let resp = await this.computeCurrentElem(subElem);
        					fields += resp.fields;
        					defs += resp.defs;
        				}
        			}
        			else{
        				let resp = await this.computeCurrentElem(elem);
        				fields += resp.fields;
        				defs += resp.defs;
        			}
        		}
        		fields += "}";
        		
        		// declare fields interFace that will hold the whole fields
        		let actions = "interface Actions {";
        		// walk the whole form
        		for(let elem of this.pageOwner.form.actions){
        			if(elem.type == "business_logic"){
        				actions += `${elem.name} : any,`;
        			}
        		}
        		actions += "}";
        		
        		defs += `
        		${fields}
        		${actions}
        		declare const fields: Fields;
        		declare const actions: Actions;
        		`
        		console.log("final defs", defs);
        		console.log("computeDefs end");
        		return defs;
        		
        	}
        	
        	public inspectValue(node, arrayNodes, str = '''', memberExpressions = null, parentNode = null) {
        	  if (parentNode == null) {
        	  	parentNode = node;
        	  }
        	  if (node.property != undefined) {
        	    // if this memberExpression has already been computed and is within another
        	    if (memberExpressions[node.property.range[0]] != undefined) {
        	      let randomSave = new Date().getTime() + ''_'' + ('''' + Math.random()).substring(2);
        	      str = '''' + `.$$START_SUB${randomSave}END_SUB$$` + str;
        	      parentNode.nested = true;
        	      if (parentNode.nestedByRandom == undefined) {
        	        parentNode.nestedByRandom = {};
        	      }
        	      parentNode.nestedByRandom[randomSave] = memberExpressions[node.property.range[0]];
        	      delete memberExpressions[node.property.range[0]];
        	    } else {
        	      	if (node.property.type == ''Literal'') {
        			  str = ''.'' + node.property.value + str;
        			} else {
        			  str = ''.'' + node.property.name + str;
        			}
        	    }
        	    return this.inspectValue(
        	      node.object,
        	      arrayNodes,
        	      str,
        	      memberExpressions,
        	      parentNode
        	    );
        	  }
        	  else {
        	    parentNode.computedValue = node.name + str;
        	    return parentNode;
        	  }
        	}
        	public async tsMonacoto$$(memberExpressions, splitted, prefixAndSuffix = true) {
        		let c8obuiltin = false;
        	    let id = this.pageOwner.getElementIdByName(splitted[1]);
        	    let pathPrefix = splitted[0];
        	    let splittedSliced = splitted.slice(1);
        	    let elem = this.pageOwner.getElementById(id);
        	    let struct = await this.pageOwner.searchCompletionWithElem(elem, false, false);
        	    // evaluate if its a builtin 
        	    if(struct.builtin != undefined && splittedSliced[1] != undefined && Object.keys(struct.builtin).indexOf(splittedSliced[1]) != -1){
        			c8obuiltin = true;
        		}
        	    debugger;
        	    let path = splittedSliced.length > 1 ? splittedSliced.join(''.'') : '''';
        	    let prefix = `$$START${id}`;
        	    let suffix = `END${id}$$`;
        	    let obj : any = 
        	    {"c8otype": "path", "c8opath": path, "c8oPrettyPath":null, "c8obuiltin": (""+c8obuiltin), "id": id, "pathPrefix": pathPrefix,
        	     "nested": memberExpressions.nested ? memberExpressions.nestedByRandom : null, "name": splitted[1] };
        		if(prefixAndSuffix){
        			return prefix+JSON.stringify(obj)+suffix;
        		}
        		else{
        			return obj;
        		}
        	    /*let str = `$$START${id}{"c8otype": "path", "c8opath": "${path}", "c8oPrettyPath":null, "c8obuiltin": null, "nested": "${
        	      memberExpressions.nested
        	        ? JSON.stringify(memberExpressions.nestedByRandom)
        	        : null
        	    }", "name":"${splitted[1]}" }END${id}$$`;
        	    return str;*/
        	}
        	public transform$toTsMonaco(str): string{
        	    try{
        			const regex = /\$\$START(\d+)(.*?)(END\d+)\$\$/;
        			let match;
        			while((match = regex.exec(str)) != null) {
        				// the whole string
        				let elem = match[0];
        				// start index
        				let iStart = match.index;
        				// end index
        	            let iEnd = match.index + match[0].length;
        	            // id based on substring
        				let id = match[1];
        				// target name
        				let name = this.pageOwner.getElementNameById(id);
        				// metas attached to expression
        				let meta = JSON.parse(match[2]);
        				// compute current type
        				let type = "";
        				if(meta.__c8otype != undefined){
        					type = meta.c8otype;
        				}
        				// if object name is not found, it''s mean that object has been deleted, use current name from meta
        				if(name == ""){
        					name = meta.name;
        				}
        				
        				let computedMeta = {};
        				if(meta.nested != null){
        					for(let nestIndex in meta.nested){
        						computedMeta[nestIndex] = this.evalMetaForTransform$toTsMonaco(meta.nested[nestIndex]);
        					}
        				}
        				let tpmstr = this.evalMetaForTransform$toTsMonaco(meta);
        				for(let nestIndex in computedMeta){
        					let strToReplace = ''"$$START_SUB''+ nestIndex+ ''END_SUB$$"'';
        					tpmstr = tpmstr.replace(strToReplace, computedMeta[nestIndex]);
        				}
        				str = str.substring(0, iStart) + tpmstr + str.substring(iEnd);
        			} 
        			if(str == undefined){
                        return "";
                    }
                    else{
                        return str;    
                    }
        	    }
        	    catch(e){
        	        this.c8o.log.error("An error occurend into transform$toHtml: \n see: \n "+ JSON.stringify(e));
        	        return "";
        	    }
        	}
        	public evalMetaForTransform$toTsMonaco(current): string{
        		let currentNestedName = this.pageOwner.getElementNameById(current.id);
        		let splitted = current.c8opath.split(".");
        		splitted[0] = currentNestedName;
        		let expression = current.pathPrefix + "." + splitted.join(".");
        		const regex = /\.([\w$]+)(?=(?:[^"]*"[^"]*")*[^"]*$)/g;
        		expression = expression.replace(regex, ''["$1"]'').replace(/^(\w+)/, ''$1'');
        		return expression;
        	}
        	public async parse(b) {
        	    console.log(''[parse] called'');
        	    let arrayNodes = [];
        	    let memberExpressions = {};
        	    // call esprima to get member expressions
        	    console.log(''[parse][esprima] called'');
        	    esprima.parse(b, { range: true }, (node, meta) => {
        	      if (node.type == ''MemberExpression'') {
        	        // its a start member
        	        if (node.object.name === ''fields'' || node.object.name === ''actions'') {
        	          memberExpressions[node.range[0]] = node;
        	        } else if (memberExpressions[node.range[0]] != undefined) {
        	          memberExpressions[node.range[0]] = node;
        	        }
        	      }
        	    });
        	    // call each memberExpressions by reverse order and extract ours
        	    Object.keys(memberExpressions)
        	      .sort((a, b) => {
        	        return +b - +a;
        	      })
        	      .forEach((key, i) => {
        	        let currentMemberExpression = memberExpressions[key];
        	        let range = currentMemberExpression.range;
        	        let res = '''';
        	        res = this.inspectValue(
        	          currentMemberExpression,
        	          arrayNodes,
        	          '''',
        	          memberExpressions
        	        );
        	        memberExpressions[range[0]] = res;
        	        arrayNodes.push({
        	          node: currentMemberExpression,
        	          range: range,
        	          childs: [],
        	          value: res,
        	        });
        	      });
        	    window[''arrayNodes''] = arrayNodes;
        	    window[''memberExpressions''] = memberExpressions;
        	    let workingB = '''' + b;
        	    console.log(''workingB'', workingB);
        	    let func1 = async()=>{
        			 // call each our memberExpressions by reverse order and extract ours. It will also allow to find nested expressions
        		    let sortedA: any = Object.keys(memberExpressions)
        		      .sort((a, b) => {
        		        return +b - +a;
        		      });
        		      for(let [i, key] of sortedA.entries()) {
        				//$$START1681726766941{\"c8otype\":\"path\",\"c8opath\":\"grid1.0.Title.displayValue\",\"c8oPrettyPath\":\"\",\"c8obuiltin\":\"false\"}END1681726766941$$
        				//"$$START1681735957413{\"c8otype\":\"path\",\"c8opath\":\"checkboxGroup1.TEXT_format.selected_data_c8o_separated_by_coma\",\"c8oPrettyPath\":\"\",\"c8obuiltin\":\"true\"}END1681735957413$$"
        				let currentMemberExpression = memberExpressions[key];
        				let range = currentMemberExpression.range;
        				if (currentMemberExpression.nested) {
        				  // do stuff for nested
        				
        				  for (let rand in currentMemberExpression.nestedByRandom) {
        				    let curr = currentMemberExpression.nestedByRandom[rand];
        				    let splitted = curr.computedValue.split(''.'');
        				    currentMemberExpression.nestedByRandom[rand] = await this.tsMonacoto$$(curr, splitted, false);
        				  }
        				}
        				let splitted = currentMemberExpression.computedValue.split(''.'');
        				let firstArg = splitted[0];
        				console.log(''splitted'', splitted);
        				if (firstArg === ''fields'' || firstArg === ''actions'') {
        				}
        				let st = await this.tsMonacoto$$(currentMemberExpression, splitted);
        				console.log(''st'', st);
        				workingB = workingB.substring(0, range[0]) + st + workingB.substring(range[1]);
        			  }
        		     
        		}
        	   	await func1();
        	    console.log(''workingB'', workingB);
        	    let ts = this.transform$toTsMonaco(workingB);
        	    console.log("ts", ts);
        	    return workingB;
        	}
        	
        	public async onMonacoInit(editor){
        		editor.onDidBlurEditorText(async ()=>{
        			let val = editor.getValue();
        			this.code = await this.parse(val);
        			let evt = C8oCafUtils.merge({"object": this, "target": this["elRef"].nativeElement}, {code: this.code})
                	this.onBlur.emit(evt);
        		})
        		console.log("onMonacoInit");
        		let defs = await this.computeDefs();
        		window["n"] = this;
        		window["esprima"] = esprima;
        		//window["jscodeshift"] = jscodeshift;
        		window["monaco"].editor.createModel(defs, ''typescript'');
        	}
        	
        	public OldinspectValue(node, arrayNodes, str = ""){
        		if(node.property != undefined && node.object != undefined){
        			// if this memberExpression has already been computed and is within another
        			if(arrayNodes[node.property.range[0]] != undefined && arrayNodes[node.property.range[0]].node.range[1] == node.range[1]){
        				str = "" + `[${arrayNodes[node.property.range[0]].value}]`;
        			}
        			else{
        				if(node.object.property){
        					str = node.object.property.name + str;
        				}
        				else{
        					str = node.object.name + str;
        				}
        				
        			}
        			str = this.inspectValue(node.object, arrayNodes, str) + "." + str;
        		}
        		else{
        			return str;
        		}
        	}
        	public OldespirimaParse(){
        		let arrayNodes = [];
        		let rangeStartToInspect = [];
        		let memberExpressions = {};
        		let alreayInsideMemberExpression = false;
        		let tmpNode = null;
        		let tmpStart = null;
        		esprima.parse(this.local.code, { range: true }, (node, meta)=>{
        		    if(node.type == "MemberExpression"){
        				// its a start member
        				if((node.object.name ==="fields" || node.object.name ==="actions" )){
        					memberExpressions[node.range[0]] = node;
        				}
        				else if(memberExpressions[node.range[0]] != undefined){
        					memberExpressions[node.range[0]] = node;
        				}
        			}
        		})
        		// get all keys by reverse order
        		Object.keys(memberExpressions).sort((a, b)=>{
        			return +b - +a;
        		})
        		.forEach((key, i)=>{
        			let currentMemberExpression = memberExpressions[key];
        			let range = currentMemberExpression.range;
        			let res = this.inspectValue(currentMemberExpression, arrayNodes);
        			arrayNodes.push({node: currentMemberExpression, range: range, childs: [], value: res})
        		})
        			//let be = fields.checkboxGroup1[fields.grid1.col1.displayName].abc;
        			/*	
        				
        				
        				
        				// if not yet inspecting member expression
        				if(!alreayInsideMemberExpression){
        					// if its a start node
        					if((node.object.name ==="fields" || node.object.name ==="actions" )){
        						tmpNode = node;
        						tmpStart = node.range[0];
        						alreayInsideMemberExpression = true;
        					}
        				}
        				// if inspecting member expression
        				else{
        					// if next member expression was from same start
        					if(node.range[0] == tmpStart){ 
        			        	tmpNode = node;
        			        	alreayInsideMemberExpression = true;
        					}
        				}
        				
        				
        				console.log("=>>currentNode", node);
        				console.log("=>>currentNode range", node.range);
        				console.log("alreayInsideMemberExpression",alreayInsideMemberExpression);
        				console.log("tmpStart",tmpStart);
        				console.log("tmpNode",tmpNode);
        				
        				if(!alreayInsideMemberExpression && (node.object.name ==="fields" || node.object.name ==="actions" )){
        					tmpNode = node;
        					tmpStart = node.range[0];
        					alreayInsideMemberExpression = true;
        				}
        				else if(node.range[0] == tmpStart){ 
        		        	tmpNode = node;
        		        	alreayInsideMemberExpression = true;
        				}
        				else {
        					debugger;
        					arrayNodes.push(JSON.parse(JSON.stringify(tmpNode)));
        					tmpNode = null;
        					tmpStart = null;
        					alreayInsideMemberExpression = false;
        				}		       
        		    }
        		})
        		*/
        		arrayNodes = arrayNodes.reverse();
        		let code = ""+ this.local.code;
        		for(let node of arrayNodes){
        			
        		}
        		
        	}
        	
        	public OldparseNode(elem){
        		if(elem.type == "ExpressionStatement"){
        			if(elem.expression.object.name === "actions"){
        				// replace at elem.expression.range [[31, 54]]
        			}
        		}
        		else{
        			
        		}
        	}
        	/*End_c8o_CompFunction*/
        '
↓SharedComponent_Event [ngx.components.UISharedComponentEvent-1681289095919]: 
  ↓installDependencies [ngx.components.UICustomAsyncAction-1681289101854]: 
    actionValue: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
        - com.twinsoft.convertigo.beans.common.FormatedContent: 
          →: |
            '		try {
            			page.local.editorOptions = {theme: ''vs-dark'', language: ''typescript''};
              			page.local.code = ''function x() {\nconsole.log("Hello world!");\n}'';
            			/*let code = `(() => {
            				console.log(fields.select1.value);
            				let sel1 = fields.select1;
            			})()`;
            			
            			let defs = `
            			
            			interface Select {
            				displayValue: string;
            				value: any;
            				getText(): string;
            			}
            			interface InputText {
            				value: string
            			}
            			interface Fields {
            			    select1: Select;
            				select2: Select;
            				inputText1: InputText;
            			}
            			
            			interface Pages {
            				count: number;
            				current: number;
            				navigateTo(pageNumber): void;
            				navigateNext(): void;
            				navigatePrevious(): void;
            			}
            			interface Form {
            				pages: Pages;
            			}
            			// global object
            			declare const fields: Fields;
            			declare const form: Form;
            			`
            			
            			monaco.editor.create(document.getElementById("container"), {
            				value: code,
            				language: "typescript",
            				automaticLayout: true,
            			});
            			monaco.editor.createModel(defs, ''typescript'');*/
            			
            			/*setTimeout(()=>{
            				monaco.editor.createModel(defs, ''typescript'');
            			}, 10000)*/
            		} catch (e) {
            			console.log("[CompMonacoEditor][afterViewInit][error]", e);
            		} finally {
            			return;
            		}
            '
    build_assets: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
        - com.twinsoft.convertigo.beans.common.XMLVector: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '{ "glob": "**/*", "input": "node_modules/monaco-editor", "output": "assets/monaco-editor" }'
    module_ng_imports: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
        - com.twinsoft.convertigo.beans.common.XMLVector: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: MonacoEditorModule.forRoot()
    module_ts_imports: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
        - com.twinsoft.convertigo.beans.common.XMLVector: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: MonacoEditorModule
              - java.lang.String: 
                - ↑value: ngx-monaco-editor
    package_dependencies: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
        - com.twinsoft.convertigo.beans.common.XMLVector: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: monaco-editor
              - java.lang.String: 
                - ↑value: 0.37.1
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: ngx-monaco-editor
              - java.lang.String: 
                - ↑value: 12.0.0
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: esprima
              - java.lang.String: 
                - ↑value: 4.0.1
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: jscodeshift
              - java.lang.String: 
                - ↑value: 0.14.0
    page_ts_imports: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
        - com.twinsoft.convertigo.beans.common.XMLVector: 
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '* as esprima'
              - java.lang.String: 
                - ↑value: esprima
          - xmlizable: 
            - ↑classname: com.twinsoft.convertigo.beans.common.XMLVector
            - com.twinsoft.convertigo.beans.common.XMLVector: 
              - java.lang.String: 
                - ↑value: '* as jscodeshift'
              - java.lang.String: 
                - ↑value: jscodeshift
↓ngx_monaco_editor [ngx.components.UIElement-1681292694675]: 
  identifier: monacoEditor
  tagName: ngx-monaco-editor
  ↓_options_ [ngx.components.UIAttribute-1681292820508]: 
    attrName: '[options]'
    attrValue: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
        - MobileSmartSourceType: script:this.local.editorOptions
  ↓attr [ngx.components.UIAttribute-1681292868963]: 
    attrName: '[ngModel]'
    attrValue: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
        - MobileSmartSourceType: script:this.transform$toTsMonaco(this.code)
  ↓attr1 [ngx.components.UIAttribute-1681293085229]: 
    attrName: (onInit)
    attrValue: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
        - MobileSmartSourceType: script:onMonacoInit($event)
  ↓attr2 [ngx.components.UIControlEvent-1681739640253]: 
    attrName: (onDidBlurEditorWidget)
    eventName: (onDidBlurEditorWidget)
    isEnabled: false
    ↓CustomAsyncAction [ngx.components.UICustomAsyncAction-1681739673034]: 
      actionValue: 
        - xmlizable: 
          - ↑classname: com.twinsoft.convertigo.beans.common.FormatedContent
          - com.twinsoft.convertigo.beans.common.FormatedContent: 
            →: |
              		try {
              			console.log("blmout");
              		} catch (e) {
              		
              		} finally {
              			return;
              		}
              
  ↓attr3 [ngx.components.UIAttribute-1686242728676]: 
    attrName: style
    attrValue: 
      - xmlizable: 
        - ↑classname: com.twinsoft.convertigo.beans.ngx.components.MobileSmartSourceType
        - MobileSmartSourceType: 'plain:height: 100%'
↓code [ngx.components.UICompVariable-1681294557081]: 
↓onBlur [ngx.components.UICompEvent-1685453920617]: 
  attrName: onBlur